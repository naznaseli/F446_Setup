/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/

#include "CatchRobo2019.hpp"
#include "USART.hpp"
#include "SerialPort.hpp"
#include <stdio.h>
#include <float.h>

int main(void)
{
    PeripheralSetup();
    DeviceSetup();

    usart1_printf("usart1\n");
    usart3_printf("usart3\n");
    //requestFlag = true;
    bool flag = true;
    for(int i = 0; i < 16; i++){
        usart3_printf("%d ", (TIM1->BDTR>>(15-i)) & 0x01);
    }

    while(1){
        led0.toggle();
        delay_ms(100);
        //dcMotor[0].setDuty(0.0);
        //float a = 1.234;
        //int b = 1;
        //usart3_printf("%f", a);
        //usart3_printf("%d", b);
        //dcM.free();
        //ductedFan[0].setup(tim9.ch1);
                //TIM5->CCMR2 &= ~(0x0070);
                //TIM5->CCMR2 |= 0x0070;
        for(int i = 0; i < 100; i++){
        //    //usart3_printf("%d\n", tim_enc[0].getCount());
            //dcM.setDuty(i);
            dcMotor[0].setDuty(i);
            dcMotor[1].setDuty(i);
            //TIM9->CCR1 = (double)(i/100) * 60000-1;    //1ms
            //TIM5->CCR3 = i*600-1;
            //TIM1->CCR3 = i*600-1;
            //TIM9->EGR |= TIM_EGR_UG;
            usart3_printf("%d\n", TIM5->CCR3);
            //usart3_printf("%d(%%)\t", i);
            delay_ms(100);
        }

        //状態、状態、mailbox0の送信リクエスト、１、２、
        //usart3_printf("%d\t%d\t%d\t%d\t%d\n", (CAN2->MSR & CAN_MSR_INAK), (CAN2->MSR & CAN_MSR_SLAK), (CAN2->sTxMailBox[0].TIR & CAN_TI0R_TXRQ), (CAN2->sTxMailBox[1].TIR & CAN_TI0R_TXRQ), (CAN2->sTxMailBox[2].TIR & CAN_TI0R_TXRQ));
        //for(int i = 0; i < 32; i++){
        //    //usart3_printf("%d ", (uint32_t)(CAN2->TSR>>(31-i) & 0x01));
        //    //usart3_printf("%d ", (uint32_t)(CAN2->RF0R>>(31-i) & 0x01));
        //    //usart3_printf("%d ", (uint32_t)(CAN2->RF1R>>(31-i) & 0x01));
        //    //usart3_printf("%d ", (uint32_t)(CAN2->ESR>>(31-i) & 0x01));
        //    //usart3_printf("%d ", (uint32_t)(CAN2->MCR>>(31-i) & 0x01));
        //    //usart3_printf("%d ", (uint32_t)(CAN2->MSR>>(31-i) & 0x01));
        //    //usart3_printf("%d ", (uint32_t)(CAN2->sTxMailBox[0].TIR>>(31-i) & 0x01));
        //}
        //usart3_printf("%d ", (uint32_t)CAN2->TSR>>26 & 0x01);
        //usart3_printf("%d ", (uint32_t)CAN2->TSR>>1 & 0x01);
        //usart3_printf("%d ", (uint32_t)CAN2->TSR & 0x01);

        //usart3_printf("\n");

        if(!button0.read() & flag){
            //requestFlag = true;
            uint8_t data[] = {0xAA, 0x55};
            can.transmit(0x10, 2, data);
            flag = false;
        }else{
            requestFlag = false;
        }

        //usart3_printf("%d\t", CAN2->MSR & CAN_MSR_INAK);
        //usart3_printf("%d\n", CAN2->MSR & CAN_MSR_SLAK);
    }

    while(1){
        //safety.cycle();
        //debug.cycle();
#if defined(DISTRIBUTED_PROCESSING) || defined(CENTRALIZED_SLAVE)
        //ローカルのセンサ取得->送信
        //canNode.send();

#endif
    }
}
